const exclusions = new Set(['WATER', 'AEA', 'MRWR', 'H.S.1 HOUR', 'RETARDER', 'AIR', 'WTR', 'HOT WATER', 'CHILL WATER', 'ADM', 'MICAFIBERS', 'ACCELGUARD']); return batchData .map(row => ({ ...row, normalizedMaterial: this.normalizeMaterialName(row['Material name']) })) .filter(row => { return row.UOM === 'LB' && !exclusions.has(row.normalizedMaterial); }) .map(row => { const ticketInfo = ticketMap.get(row['Ticket number']); const ticketDate = this.parseDate(ticketInfo?.date); const target = parseFloat(row.Target) || 0; const actual = parseFloat(row.Actual) || 0; const errorPercent = target !== 0 ? ((actual - target) / target) * 100 : 0; return { ...row, ticketDate, target, actual, errorPercent, region: regionName, plant: ticketInfo?.plant || 'Unknown Plant', monthYear: this.getMonthYear(ticketDate), weekStart: this.getWeekStart(ticketDate), status: this.categorizeError(errorPercent) }; }) .filter(row => row.ticketDate && !isNaN(row.ticketDate.getTime())) .filter(row => Math.abs(row.errorPercent) <= 10); // Remove extreme outliers } normalizeMaterialName(name) { if (typeof name !== 'string') return ''; const normalized = name.trim().toUpperCase(); const replacements = { 'PORTLAND CEMENT': 'CEMENT', '30S CONCRETE STO': 'CSAND', 'CONC SAND': 'CSAND' }; return replacements[normalized] || normalized; } parseDate(dateValue) { if (typeof dateValue === 'number') { return new Date(Date.UTC(0, 0, dateValue - 1)); } return new Date(dateValue); } getMonthYear(date) { return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`; } getWeekStart(date) { const d = new Date(date); const day = d.getDay(); const diff = d.getDate() - day + (day === 0 ? -6 : 1); return new Date(d.setDate(diff)).toISOString().split('T')[0]; } categorizeError(error) { if (error <= 0 && error >= -1) return 'optimal'; if (error > 0 && error <= 1) return 'good'; if (error < -1) return 'risk'; if (error > 1) return 'waste'; return 'good'; } updateMasterLists() { this.materials.clear(); this.regions.clear(); this.plants.clear(); this.months.clear(); this.data.forEach(item => { this.materials.add(item.normalizedMaterial); this.regions.add(item.region); this.plants.add(item.plant); this.months.add(item.monthYear); }); this.selectedMaterials = Array.from(this.materials); this.selectedRegions = Array.from(this.regions); this.selectedPlants = Array.from(this.plants); this.selectedMonth = Array.from(this.months).sort().pop() || ''; this.updateFilters(); } updateFilters() { const filtersDiv = document.getElementById('filters'); const filterSections = document.getElementById('filter-sections'); filtersDiv.classList.remove('hidden'); filterSections.innerHTML = ''; // Month filter if (this.months.size > 0) { const monthSection = this.createFilterSection('Month', Array.from(this.months).sort().reverse(), this.selectedMonth, 'month', true); filterSections.appendChild(monthSection); } // Other filters if (this.regions.size > 0) { const regionSection = this.createFilterSection('Regions', Array.from(this.regions).sort(), this.selectedRegions, 'regions'); filterSections.appendChild(regionSection); } if (this.plants.size > 0) { const plantSection = this.createFilterSection('Plants', Array.from(this.plants).sort(), this.selectedPlants, 'plants'); filterSections.appendChild(plantSection); } if (this.materials.size > 0) { const materialSection = this.createFilterSection('Materials', Array.from(this.materials).sort(), this.selectedMaterials, 'materials'); filterSections.appendChild(materialSection); } this.updateFilterTags(); } createFilterSection(title, items, selected, type, isSelect = false) { const section = document.createElement('div'); section.className = 'glass-dark rounded-xl p-4'; const header = document.createElement('h4'); header.className = 'font-medium text-white mb-3'; header.textContent = title; section.appendChild(header); if (isSelect) { const select = document.createElement('select'); select.className = 'w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-white'; items.forEach(item => { const option = document.createElement('option'); option.value = item; option.textContent = item; option.selected = selected === item; option.className = 'text-gray-800'; select.appendChild(option); }); select.addEventListener('change', () => { if (type === 'month') { this.selectedMonth = select.value; } this.updateVisualizations(); this.updateFilterTags(); }); section.appendChild(select); } else { const buttons = document.createElement('div'); buttons.className = 'flex space-x-2 mb-3'; const selectAll = document.createElement('button'); selectAll.className = 'flex-1 bg-white/10 hover:bg-white/20 text-white px-3 py-1 rounded-lg text-sm transition-colors'; selectAll.textContent = 'All'; selectAll.addEventListener('click', () => { if (type === 'regions') this.selectedRegions = Array.from(this.regions); if (type === 'plants') this.selectedPlants = Array.from(this.plants); if (type === 'materials') this.selectedMaterials = Array.from(this.materials); this.updateFilters(); this.updateVisualizations(); }); const selectNone = document.createElement('button'); selectNone.className = 'flex-1 bg-white/10 hover:bg-white/20 text-white px-3 py-1 rounded-lg text-sm transition-colors'; selectNone.textContent = 'None'; selectNone.addEventListener('click', () => { if (type === 'regions') this.selectedRegions = []; if (type === 'plants') this.selectedPlants = []; if (type === 'materials') this.selectedMaterials = []; this.updateFilters(); this.updateVisualizations(); }); buttons.appendChild(selectAll); buttons.appendChild(selectNone); section.appendChild(buttons); const itemsContainer = document.createElement('div'); itemsContainer.className = 'space-y-2 max-h-32 overflow-y-auto'; items.forEach(item => { const label = document.createElement('label'); label.className = 'flex items-center space-x-2 cursor-pointer hover:bg-white/5 rounded p-1 transition-colors'; const checkbox = document.createElement('input'); checkbox.type = 'checkbox'; checkbox.className = 'rounded border-white/30 bg-white/10 text-blue-500'; checkbox.checked = selected.includes(item); checkbox.addEventListener('change', () => { let targetArray; if (type === 'regions') targetArray = this.selectedRegions; if (type === 'plants') targetArray = this.selectedPlants; if (type === 'materials') targetArray = this.selectedMaterials; if (checkbox.checked) { if (!targetArray.includes(item)) targetArray.push(item); } else { const index = targetArray.indexOf(item); if (index > -1) targetArray.splice(index, 1); } this.updateVisualizations(); this.updateFilterTags(); }); const span = document.createElement('span'); span.className = 'text-white/90 text-sm'; span.textContent = item; label.appendChild(checkbox); label.appendChild(span); itemsContainer.appendChild(label); }); section.appendChild(itemsContainer); } return section; } updateFilterTags() { const filterTags = document.getElementById('filter-tags'); filterTags.innerHTML = ''; const tags = [ { label: `Month: ${this.selectedMonth}`, type: 'month' }, { label: `Regions: ${this.selectedRegions.length}`, type: 'regions' }, { label: `Plants: ${this.selectedPlants.length}`, type: 'plants' }, { label: `Materials: ${this.selectedMaterials.length}`, type: 'materials' } ]; tags.forEach(tag => { const tagElement = document.createElement('span'); tagElement.className = 'filter-tag'; tagElement.textContent = tag.label; filterTags.appendChild(tagElement); }); } filterData() { this.filteredData = this.data.filter(item => this.selectedRegions.includes(item.region) && this.selectedPlants.includes(item.plant) && this.selectedMaterials.includes(item.normalizedMaterial) && item.monthYear === this.selectedMonth ); } updateVisualizations() { this.filterData(); this.updateMetricCards(); this.updateCharts(); this.updateTable(); this.updateDashboardSubtitle(); } updateDashboardSubtitle() { const subtitle = document.getElementById('dashboard-subtitle'); if (this.filteredData.length > 0) { const uniquePlants = new Set(this.filteredData.map(d => d.plant)).size; subtitle.textContent = `${this.filteredData.length.toLocaleString()} batches • ${uniquePlants} plants • ${this.selectedMonth}`; } } updateMetricCards() { const metricCards = document.getElementById('metric-cards'); metricCards.innerHTML = ''; if (this.filteredData.length === 0) { metricCards.innerHTML = '
No data matches current filters

'; return; } const stats = this.calculateStats(); const cards = [ { title: 'Total Batches', value: stats.totalBatches.toLocaleString(), icon: '📊', color: this.colors.primary, subtitle: `Across ${new Set(this.filteredData.map(d => d.plant)).size} plants` }, { title: 'Average Error', value: `${stats.avgError.toFixed(2)}%`, icon: '🎯', color: Math.abs(stats.avgError) > 1 ? this.colors.waste : this.colors.optimal, subtitle: stats.avgError > 0 ? 'Over target' : 'Under target' }, { title: 'Optimal Batches', value: `${((stats.optimal / stats.totalBatches) * 100).toFixed(1)}%`, icon: '✅', color: this.colors.optimal, subtitle: `${stats.optimal} batches` }, { title: 'Risk/Waste', value: `${(((stats.risk + stats.waste) / stats.totalBatches) * 100).toFixed(1)}%`, icon: '⚠️', color: this.colors.waste, subtitle: `${stats.risk + stats.waste} batches` } ]; cards.forEach(card => { const cardElement = document.createElement('div'); cardElement.className = 'metric-card rounded-2xl p-6 animate-slide-up'; cardElement.style.borderLeftColor = card.color; cardElement.innerHTML = `
${card.icon} ${card.value}
${card.title}
${card.subtitle}

`; metricCards.appendChild(cardElement); }); } calculateStats() { const statusCounts = _.countBy(this.filteredData, 'status'); const avgError = _.sumBy(this.filteredData, 'errorPercent') / this.filteredData.length; return { totalBatches: this.filteredData.length, avgError, optimal: statusCounts.optimal || 0, good: statusCounts.good || 0, risk: statusCounts.risk || 0, waste: statusCounts.waste || 0 }; } updateCharts() { this.updateTrendChart(); this.updateDistributionChart(); this.updateMaterialChart(); } updateTrendChart() { const ctx = document.getElementById('trend-chart').getContext('2d'); if (this.charts.trend) { this.charts.trend.destroy(); } const weeklyData = _.groupBy(this.filteredData, 'weekStart'); const weeks = Object.keys(weeklyData).sort(); const datasets = []; // Smart grouping based on number of plants if (this.selectedPlants.length <= 4) { // Show individual plants when <= 4 const plantColors = this.generateColorPalette(this.selectedPlants.length); this.selectedPlants.forEach((plant, index) => { const plantData = weeks.map(week => { const weekBatches = weeklyData[week]?.filter(b => b.plant === plant) || []; return weekBatches.length > 0 ? _.sumBy(weekBatches, 'errorPercent') / weekBatches.length : null; }); // Clean plant names - remove region prefix and plant numbers const cleanPlantName = plant .replace(/PLANT \d+ - /gi, '') .replace(/\(\d+\)/g, '') .trim(); datasets.push({ label: cleanPlantName, data: plantData, borderColor: plantColors[index], backgroundColor: plantColors[index] + '20', borderWidth: 3, tension: 0.4, fill: false, pointRadius: 4, pointHoverRadius: 6 }); }); } else { // Group by region when > 4 plants const regionData = {}; // First, collect all batches by region this.filteredData.forEach(batch => { let region = batch.region || 'Unknown'; // Clean up region names region = region.trim().toUpperCase(); if (region.includes('ALLIED')) region = 'ALLIED'; if (region.includes('RK HALL') || region.includes('HALL')) region = 'RK HALL'; if (!regionData[region]) { regionData[region] = {}; } const week = batch.weekStart; if (!regionData[region][week]) { regionData[region][week] = []; } regionData[region][week].push(batch.errorPercent); }); // Create datasets for each region const regionColors = this.generateColorPalette(Object.keys(regionData).length); Object.keys(regionData).forEach((region, index) => { const regionWeeklyAvg = weeks.map(week => { const weekErrors = regionData[region][week]; return weekErrors && weekErrors.length > 0 ? _.sum(weekErrors) / weekErrors.length : null; }); datasets.push({ label: `${region} Region`, data: regionWeeklyAvg, borderColor: regionColors[index], backgroundColor: regionColors[index] + '20', borderWidth: 4, tension: 0.4, fill: false, pointRadius: 5, pointHoverRadius: 8 }); }); } // Calculate dynamic Y-axis range const allValues = datasets.flatMap(d => d.data.filter(v => v !== null)); const minValue = Math.min(...allValues); const maxValue = Math.max(...allValues); const range = Math.max(Math.abs(minValue), Math.abs(maxValue)); const padding = range * 0.2; // 20% padding this.charts.trend = new Chart(ctx, { type: 'line', data: { labels: weeks.map(week => { // Format week labels to be more readable const date = new Date(week); return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }); }), datasets }, options: { responsive: true, maintainAspectRatio: false, interaction: { intersect: false, mode: 'index' }, plugins: { legend: { position: 'top', labels: { usePointStyle: true, padding: 20, font: { size: 12 } } }, tooltip: { backgroundColor: 'rgba(0,0,0,0.8)', titleColor: 'white', bodyColor: 'white', borderColor: 'rgba(255,255,255,0.2)', borderWidth: 1, cornerRadius: 8, callbacks: { label: function(context) { const value = context.parsed.y; if (value === null) return null; return `${context.dataset.label}: ${value.toFixed(2)}%`; } } } }, scales: { y: { title: { display: true, text: 'Average Error %', font: { weight: 'bold' } }, min: Math.min(-1, minValue - padding), max: Math.max(1, maxValue + padding), ticks: { callback: value => `${value.toFixed(1)}%`, stepSize: 0.1 }, grid: { color: 'rgba(0,0,0,0.1)', drawBorder: true } }, x: { title: { display: true, text: 'Week Starting', font: { weight: 'bold' } }, grid: { color: 'rgba(0,0,0,0.1)' } } } } }); } updateDistributionChart() { const ctx = document.getElementById('distribution-chart').getContext('2d'); if (this.charts.distribution) { this.charts.distribution.destroy(); } const plantStats = {}; this.selectedPlants.forEach(plant => { const plantBatches = this.filteredData.filter(b => b.plant === plant); const statusCounts = _.countBy(plantBatches, 'status'); const total = plantBatches.length; if (total > 0) { plantStats[plant] = { optimal: (statusCounts.optimal || 0) / total * 100, good: (statusCounts.good || 0) / total * 100, risk: (statusCounts.risk || 0) / total * 100, waste: (statusCounts.waste || 0) / total * 100, total: total }; } }); const plants = Object.keys(plantStats); // Clean plant names for display const cleanPlantNames = plants.map(plant => plant.replace(/PLANT \d+ - /gi, '').replace(/\(\d+\)/g, '').trim() ); const datasets = [ { label: 'Optimal', data: plants.map(plant => plantStats[plant].optimal), backgroundColor: this.colors.optimal }, { label: 'Good', data: plants.map(plant => plantStats[plant].good), backgroundColor: this.colors.good }, { label: 'Risk', data: plants.map(plant => plantStats[plant].risk), backgroundColor: this.colors.risk }, { label: 'Waste', data: plants.map(plant => plantStats[plant].waste), backgroundColor: this.colors.waste } ]; this.charts.distribution = new Chart(ctx, { type: 'bar', data: { labels: cleanPlantNames, datasets }, options: { responsive: true, maintainAspectRatio: false, interaction: { intersect: false, mode: 'index' }, scales: { x: { stacked: true, title: { display: true, text: 'Plants', font: { weight: 'bold' } } }, y: { stacked: true, title: { display: true, text: 'Percentage of Batches', font: { weight: 'bold' } }, ticks: { callback: value => `${value.toFixed(0)}%` }, grid: { color: 'rgba(0,0,0,0.1)' } } }, plugins: { legend: { position: 'top', labels: { usePointStyle: true, padding: 15 } }, tooltip: { backgroundColor: 'rgba(0,0,0,0.8)', titleColor: 'white', bodyColor: 'white', borderColor: 'rgba(255,255,255,0.2)', borderWidth: 1, cornerRadius: 8, callbacks: { title: function(context) { const plantIndex = context[0].dataIndex; const originalPlant = plants[plantIndex]; const total = plantStats[originalPlant].total; return `${context[0].label} (${total} batches)`; }, label: function(context) { const value = context.parsed.y; const plantIndex = context.dataIndex; const originalPlant = plants[plantIndex]; const total = plantStats[originalPlant].total; const count = Math.round((value / 100) * total); return `${context.dataset.label}: ${value.toFixed(1)}% (${count} batches)`; } } }, datalabels: false }, onHover: function(event, activeElements) { event.native.target.style.cursor = activeElements.length > 0 ? 'pointer' : 'default'; } }, plugins: [{ id: 'percentageLabels', afterDatasetsDraw: function(chart) { const ctx = chart.ctx; chart.data.datasets.forEach((dataset, datasetIndex) => { const meta = chart.getDatasetMeta(datasetIndex); meta.data.forEach((bar, index) => { const value = dataset.data[index]; if (value >= 5) { const x = bar.x; const y = bar.y + (bar.height / 2); ctx.save(); ctx.fillStyle = '#ffffff'; ctx.font = 'bold 12px Inter, sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 3; ctx.shadowOffsetX = 1; ctx.shadowOffsetY = 1; ctx.fillText(`${value.toFixed(1)}%`, x, y); ctx.restore(); } }); }); } }] }); } updateMaterialChart() { const ctx = document.getElementById('material-chart').getContext('2d'); if (this.charts.material) { this.charts.material.destroy(); } const materialStats = {}; this.selectedMaterials.forEach(material => { const materialBatches = this.filteredData.filter(b => b.normalizedMaterial === material); if (materialBatches.length > 0) { const avgError = _.sumBy(materialBatches, 'errorPercent') / materialBatches.length; const statusCounts = _.countBy(materialBatches, 'status'); materialStats[material] = { avgError, count: materialBatches.length, optimal: statusCounts.optimal || 0, risk: statusCounts.risk || 0, waste: statusCounts.waste || 0 }; } }); const materials = Object.keys(materialStats); this.charts.material = new Chart(ctx, { type: 'bar', data: { labels: materials, datasets: [{ label: 'Average Error %', data: materials.map(material => materialStats[material].avgError), backgroundColor: materials.map((material) => { const error = materialStats[material].avgError; if (error <= 0 && error >= -1) return this.colors.optimal + '80'; if (error > 0 && error <= 1) return this.colors.good + '80'; if (error < -1) return this.colors.risk + '80'; return this.colors.waste + '80'; }), borderColor: materials.map((material) => { const error = materialStats[material].avgError; if (error <= 0 && error >= -1) return this.colors.optimal; if (error > 0 && error <= 1) return this.colors.good; if (error < -1) return this.colors.risk; return this.colors.waste; }), borderWidth: 2 }] }, options: { responsive: true, maintainAspectRatio: false, scales: { y: { title: { display: true, text: 'Average Error %', font: { weight: 'bold' } }, ticks: { callback: value => `${value.toFixed(1)}%` } }, x: { title: { display: true, text: 'Materials', font: { weight: 'bold' } } } }, plugins: { legend: { display: false }, tooltip: { callbacks: { afterLabel: (context) => { const material = materials[context.dataIndex]; const stats = materialStats[material]; return [ `Batches: ${stats.count}`, `Optimal: ${stats.optimal}`, `Risk: ${stats.risk}`, `Waste: ${stats.waste}` ]; } } } }, onClick: (event, elements) => { if (elements.length > 0) { const index = elements[0].index; const material = materials[index]; this.showMaterialDetails(material); } } } }); } updateTable() { const tableHeader = document.getElementById('table-header'); const tableBody = document.getElementById('table-body'); tableHeader.innerHTML = ''; tableBody.innerHTML = ''; // Create header const headers = ['Material', 'Total Batches', 'Avg Error %', 'Optimal', 'Good', 'Risk', 'Waste']; headers.forEach(header => { const th = document.createElement('th'); th.className = 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider'; th.textContent = header; tableHeader.appendChild(th); }); 