<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Concrete Batch Performance Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    
    <style>
        * { font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; }
        
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .glass {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .glass-dark {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .card:hover {
            transform: translateY(-4px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }
        
        .metric-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.85));
            border-left: 4px solid;
            transition: all 0.3s ease;
        }
        
        .metric-card:hover {
            transform: scale(1.02);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
        }
        
        .upload-zone {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            border: 2px dashed rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
        }
        
        .upload-zone:hover {
            border-color: rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.15);
        }
        
        .upload-zone.dragover {
            border-color: #60a5fa;
            background: rgba(96, 165, 250, 0.1);
            transform: scale(1.02);
        }
        
        .chart-container {
            position: relative;
            height: 350px;
            padding: 20px;
        }
        
        .filter-tag {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            margin: 0.125rem;
            transition: all 0.2s ease;
        }
        
        .performance-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        
        .optimal { background: linear-gradient(135deg, #10b981, #065f46); }
        .good { background: linear-gradient(135deg, #eab308, #ca8a04); }
        .risk { background: linear-gradient(135deg, #f97316, #ea580c); }
        .waste { background: linear-gradient(135deg, #ef4444, #dc2626); }
        
        .animate-fade-in { animation: fadeIn 0.6s ease-out; }
        .animate-slide-up { animation: slideUp 0.8s ease-out; }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes slideUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .loading-dots::after {
            content: '';
            animation: dots 1.5s steps(5, end) infinite;
        }
        
        @keyframes dots {
            0%, 20% { content: ''; }
            40% { content: '.'; }
            60% { content: '..'; }
            80%, 100% { content: '...'; }
        }
        
        .sidebar {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            backdrop-filter: blur(20px);
            border-right: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .data-table {
            background: rgba(255, 255, 255, 0.98);
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        
        .table-row:hover {
            background: rgba(102, 126, 234, 0.05);
            transform: scale(1.001);
        }
    </style>
</head>
<body class="text-white overflow-x-hidden">

<div class="min-h-screen flex">
    <!-- Sidebar -->
    <div id="sidebar" class="w-80 sidebar p-6 overflow-y-auto">
        <div class="mb-8">
            <h1 class="text-2xl font-bold text-white mb-2">Concrete Analytics</h1>
            <p class="text-white/70 text-sm">Advanced batch performance insights</p>
            <div class="mt-2 text-xs text-white/50">v1.0 | Multi-Region Dashboard</div>
        </div>

        <!-- Upload Zone -->
        <div id="upload-zone" class="upload-zone rounded-2xl p-8 text-center mb-6 cursor-pointer">
            <input type="file" id="file-input" multiple accept=".xlsx" class="hidden">
            <div class="text-white/80">
                <svg class="w-12 h-12 mx-auto mb-4 opacity-60" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
                </svg>
                <p class="font-medium mb-1">Drop Excel files here</p>
                <p class="text-sm opacity-70">or click to browse</p>
                <div class="mt-2 text-xs opacity-50">Supports: .xlsx files with "Batch weights" & "Tickets" sheets</div>
            </div>
        </div>

        <!-- Loading -->
        <div id="loading" class="hidden text-center py-4">
            <div class="inline-block w-8 h-8 border-2 border-white/30 border-t-white rounded-full animate-spin mb-2"></div>
            <p class="text-sm text-white/80 loading-dots">Processing files</p>
        </div>

        <!-- Controls -->
        <div id="controls" class="space-y-4 hidden">
            <button id="clear-btn" class="w-full bg-red-500/80 hover:bg-red-500 text-white px-4 py-2 rounded-lg transition-all duration-300 flex items-center justify-center">
                <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                </svg>
                Clear Data
            </button>
        </div>

        <!-- Filters -->
        <div id="filters" class="space-y-6 hidden">
            <div>
                <h3 class="font-semibold text-white mb-3">Active Filters</h3>
                <div id="filter-tags" class="flex flex-wrap"></div>
            </div>
            <div id="filter-sections" class="space-y-4"></div>
        </div>

        <!-- Footer -->
        <div class="mt-8 text-center text-white/40 text-xs">
            <p>¬© 2025 Concrete Analytics</p>
            <p>Built with Chart.js & Tailwind CSS</p>
        </div>
    </div>

    <!-- Main Content -->
    <div class="flex-1 p-6">
        <!-- Welcome Screen -->
        <div id="welcome" class="flex items-center justify-center h-full">
            <div class="text-center glass rounded-3xl p-12 max-w-2xl mx-auto">
                <div class="w-24 h-24 mx-auto mb-6 rounded-full bg-gradient-to-br from-white/20 to-white/10 flex items-center justify-center">
                    <svg class="w-12 h-12 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"/>
                    </svg>
                </div>
                <h2 class="text-3xl font-bold text-white mb-4">Welcome to Concrete Analytics</h2>
                <p class="text-white/80 text-lg mb-6 max-w-md mx-auto">Upload your Excel files to unlock powerful insights into batch performance, material efficiency, and quality metrics across multiple regions.</p>
                <div class="text-white/60 text-sm space-y-1">
                    <p>‚úì Multi-region analysis (ALLIED vs RK HALL)</p>
                    <p>‚úì Real-time filtering and drill-down capabilities</p>
                    <p>‚úì Interactive visualizations and export functions</p>
                    <p>‚úì Performance categorization and trending</p>
                </div>
                
                <div class="mt-8 p-4 bg-white/10 rounded-lg text-left text-sm text-white/70">
                    <h4 class="font-semibold mb-2">üìÅ File Requirements:</h4>
                    <ul class="space-y-1 text-xs">
                        <li>‚Ä¢ Excel files (.xlsx format)</li>
                        <li>‚Ä¢ "Batch weights" sheet with material data</li>
                        <li>‚Ä¢ "Tickets" sheet with plant and date information</li>
                        <li>‚Ä¢ Naming convention: "REGION MONTH YEAR.xlsx"</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Dashboard -->
        <div id="dashboard" class="hidden animate-fade-in">
            <!-- Header Stats -->
            <div class="mb-8">
                <div class="flex justify-between items-center mb-6">
                    <div>
                        <h2 class="text-3xl font-bold text-white">Performance Dashboard</h2>
                        <p class="text-white/70 text-sm mt-1" id="dashboard-subtitle">Real-time concrete batch analytics</p>
                    </div>
                </div>
                <div id="metric-cards" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6"></div>
            </div>

            <!-- Charts Grid -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                <!-- Weekly Trend -->
                <div class="card rounded-2xl p-6">
                    <h3 class="text-xl font-bold text-gray-800 mb-4">Weekly Performance Trend</h3>
                    <div class="chart-container">
                        <canvas id="trend-chart"></canvas>
                    </div>
                </div>

                <!-- Performance Distribution -->
                <div class="card rounded-2xl p-6">
                    <h3 class="text-xl font-bold text-gray-800 mb-4">Performance Distribution</h3>
                    <div class="chart-container">
                        <canvas id="distribution-chart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Material Performance -->
            <div class="card rounded-2xl p-6 mb-8">
                <h3 class="text-xl font-bold text-gray-800 mb-4">Material Performance Analysis</h3>
                <div class="chart-container" style="height: 400px;">
                    <canvas id="material-chart"></canvas>
                </div>
            </div>

            <!-- Detailed Table -->
            <div class="data-table">
                <div class="p-6 border-b border-gray-100">
                    <h3 class="text-xl font-bold text-gray-800">Detailed Performance Data</h3>
                </div>
                <div class="overflow-x-auto">
                    <table class="w-full">
                        <thead class="bg-gray-50">
                            <tr id="table-header"></tr>
                        </thead>
                        <tbody id="table-body"></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Material Detail Modal -->
<div id="modal" class="fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center p-4 hidden z-50">
    <div class="card rounded-2xl max-w-6xl w-full max-h-[90vh] overflow-hidden">
        <div class="p-6 border-b border-gray-100 flex justify-between items-center">
            <h3 id="modal-title" class="text-2xl font-bold text-gray-800"></h3>
            <button id="modal-close" class="text-gray-400 hover:text-gray-600 transition-colors">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                </svg>
            </button>
        </div>
        <div class="p-6 overflow-y-auto max-h-[70vh]">
            <div class="overflow-x-auto">
                <table class="w-full">
                    <thead class="bg-gray-50 sticky top-0">
                        <tr>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Plant</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Date</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Ticket #</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Target (LB)</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Actual (LB)</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Error %</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Status</th>
                        </tr>
                    </thead>
                    <tbody id="modal-table-body"></tbody>
                </table>
            </div>
        </div>
    </div>
</div>

<script>
class ConcreteAnalyzer {
    constructor() {
        this.data = [];
        this.filteredData = [];
        this.materials = new Set();
        this.regions = new Set();
        this.plants = new Set();
        this.months = new Set();
        
        this.selectedMaterials = [];
        this.selectedRegions = [];
        this.selectedPlants = [];
        this.selectedStartMonth = '';
        this.selectedEndMonth = '';
        this.viewMode = 'aggregated'; // 'aggregated' or 'breakdown'
        
        this.colors = {
            optimal: '#10b981',
            good: '#eab308',
            risk: '#f97316',
            waste: '#ef4444',
            primary: '#667eea',
            secondary: '#764ba2'
        };
        
        this.charts = {};
        this.initializeEventListeners();
    }
    
    initializeEventListeners() {
        const uploadZone = document.getElementById('upload-zone');
        const fileInput = document.getElementById('file-input');
        
        uploadZone.addEventListener('click', () => fileInput.click());
        uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZone.classList.add('dragover');
        });
        uploadZone.addEventListener('dragleave', () => {
            uploadZone.classList.remove('dragover');
        });
        uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZone.classList.remove('dragover');
            this.handleFiles(e.dataTransfer.files);
        });
        
        fileInput.addEventListener('change', (e) => {
            this.handleFiles(e.target.files);
        });
        
        document.getElementById('clear-btn').addEventListener('click', () => {
            this.clearData();
        });
        
        document.getElementById('modal-close').addEventListener('click', () => {
            document.getElementById('modal').classList.add('hidden');
        });
    }
    
    async handleFiles(files) {
        if (files.length === 0) return;
        
        this.showLoading();
        this.data = [];
        
        for (let file of files) {
            await this.processFile(file);
        }
        
        this.updateMasterLists();
        this.hideLoading();
        this.showDashboard();
        this.updateVisualizations();
    }
    
    async processFile(file) {
        try {
            const buffer = await file.arrayBuffer();
            const workbook = XLSX.read(buffer);
            
            if (!workbook.SheetNames.includes('Batch weights') || !workbook.SheetNames.includes('Tickets')) {
                throw new Error('Missing required sheets');
            }
            
            const batchData = XLSX.utils.sheet_to_json(workbook.Sheets['Batch weights']);
            const ticketData = XLSX.utils.sheet_to_json(workbook.Sheets['Tickets']);
            
            const regionName = this.extractRegionName(file.name);
            const ticketMap = this.createTicketMap(ticketData);
            
            const processedBatches = this.processBatchData(batchData, ticketMap, regionName);
            this.data.push(...processedBatches);
            
        } catch (error) {
            console.error('Error processing file:', file.name, error);
        }
    }
    
    extractRegionName(filename) {
        const upperName = filename.toUpperCase();
        if (upperName.startsWith('JUNE 2025.XLSX')) return 'ALLIED';
        
        const patterns = [
            /^(.*?)\s*(?:JAN|FEB|MARCH|APRIL|MAY|JUNE|JULY|AUG|SEPT|OCT|NOV|DEC)/i,
            /^(.*?)\s*\d{4}/,
            /^(.*?)\s*(?:REGION|PLANT)/i
        ];
        
        for (const pattern of patterns) {
            const match = filename.match(pattern);
            if (match && match[1].trim()) {
                let regionName = match[1].trim().toUpperCase();
                regionName = regionName.replace(/\s+/g, ' ').replace(/\.$/, '').trim();
                if (regionName.length > 0) return regionName;
            }
        }
        
        const fallbackMatch = filename.match(/^([^.\s]+)/);
        if (fallbackMatch && fallbackMatch[1]) {
            return fallbackMatch[1].toUpperCase();
        }
        
        return filename.replace(/\.[^/.]+$/, "").toUpperCase();
    }
    
    createTicketMap(ticketData) {
        const map = new Map();
        ticketData.forEach(ticket => {
            const plantName = ticket['Plant name'] || ticket['Plant Name'] || ticket['Plant'] || 'Unknown Plant';
            map.set(ticket['Ticket number'], {
                date: ticket['Ticketed'],
                plant: plantName
            });
        });
        return map;
    }
    
    processBatchData(batchData, ticketMap, regionName) {
        const exclusions = new Set(['WATER', 'AEA', 'MRWR', 'H.S.1 HOUR', 'RETARDER', 'AIR', 'WTR', 'HOT WATER', 'CHILL WATER', 'ADM', 'MICAFIBERS', 'ACCELGUARD']);
        
        return batchData
            .map(row => ({
                ...row,
                normalizedMaterial: this.normalizeMaterialName(row['Material name'])
            }))
            .filter(row => {
                return row.UOM === 'LB' && !exclusions.has(row.normalizedMaterial);
            })
            .map(row => {
                const ticketInfo = ticketMap.get(row['Ticket number']);
                const ticketDate = this.parseDate(ticketInfo?.date);
                const target = parseFloat(row.Target) || 0;
                const actual = parseFloat(row.Actual) || 0;
                const errorPercent = target !== 0 ? ((actual - target) / target) * 100 : 0;
                
                return {
                    ...row,
                    ticketDate,
                    target,
                    actual,
                    errorPercent,
                    region: regionName,
                    plant: ticketInfo?.plant || 'Unknown Plant',
                    monthYear: this.getMonthYear(ticketDate),
                    weekStart: this.getWeekStart(ticketDate),
                    status: this.categorizeError(errorPercent)
                };
            })
            .filter(row => row.ticketDate && !isNaN(row.ticketDate.getTime()))
            .filter(row => Math.abs(row.errorPercent) <= 10);
    }
    
    normalizeMaterialName(name) {
        if (typeof name !== 'string') return '';
        const normalized = name.trim().toUpperCase();
        const replacements = {
            'PORTLAND CEMENT': 'CEMENT',
            '30S CONCRETE STO': 'CSAND',
            'CONC SAND': 'CSAND'
        };
        return replacements[normalized] || normalized;
    }
    
    parseDate(dateValue) {
        if (typeof dateValue === 'number') {
            return new Date(Date.UTC(0, 0, dateValue - 1));
        }
        return new Date(dateValue);
    }
    
    getMonthYear(date) {
        return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
    }
    
    getWeekStart(date) {
        const d = new Date(date);
        const day = d.getDay();
        const diff = d.getDate() - day + (day === 0 ? -6 : 1);
        return new Date(d.setDate(diff)).toISOString().split('T')[0];
    }
    
    categorizeError(error) {
        if (error <= 0 && error >= -1) return 'optimal';
        if (error > 0 && error <= 1) return 'good';
        if (error < -1) return 'risk';
        if (error > 1) return 'waste';
        return 'good';
    }
    
    updateMasterLists() {
        this.materials.clear();
        this.regions.clear();
        this.plants.clear();
        this.months.clear();
        
        this.data.forEach(item => {
            this.materials.add(item.normalizedMaterial);
            this.regions.add(item.region);
            this.plants.add(item.plant);
            this.months.add(item.monthYear);
        });
        
        this.selectedMaterials = Array.from(this.materials);
        this.selectedRegions = Array.from(this.regions);
        this.selectedPlants = Array.from(this.plants);
        
        // Set default date range: latest month to latest month
        const sortedMonths = Array.from(this.months).sort();
        const latestMonth = sortedMonths.pop() || '';
        this.selectedStartMonth = latestMonth;
        this.selectedEndMonth = latestMonth;
        
        this.updateFilters();
    }
    
    updateFilters() {
        const filtersDiv = document.getElementById('filters');
        const filterSections = document.getElementById('filter-sections');
        
        filtersDiv.classList.remove('hidden');
        filterSections.innerHTML = '';
        
        if (this.months.size > 0) {
            const dateRangeSection = this.createDateRangeSection();
            filterSections.appendChild(dateRangeSection);
        }
        
        if (this.regions.size > 0) {
            const regionSection = this.createFilterSection('Regions', Array.from(this.regions).sort(), this.selectedRegions, 'regions');
            filterSections.appendChild(regionSection);
        }
        
        if (this.plants.size > 0) {
            const plantSection = this.createFilterSection('Plants', Array.from(this.plants).sort(), this.selectedPlants, 'plants');
            filterSections.appendChild(plantSection);
        }
        
        if (this.materials.size > 0) {
            const materialSection = this.createFilterSection('Materials', Array.from(this.materials).sort(), this.selectedMaterials, 'materials');
            filterSections.appendChild(materialSection);
        }
        
        this.updateFilterTags();
    }
    
    createDateRangeSection() {
        const section = document.createElement('div');
        section.className = 'glass-dark rounded-xl p-4';
        
        const header = document.createElement('h4');
        header.className = 'font-medium text-white mb-3';
        header.textContent = 'Date Range';
        section.appendChild(header);
        
        // View mode toggle
        const viewModeContainer = document.createElement('div');
        viewModeContainer.className = 'mb-4';
        
        const viewModeLabel = document.createElement('label');
        viewModeLabel.className = 'text-white/90 text-sm block mb-2';
        viewModeLabel.textContent = 'View Mode:';
        viewModeContainer.appendChild(viewModeLabel);
        
        const viewModeToggle = document.createElement('div');
        viewModeToggle.className = 'flex space-x-2';
        
        const aggregatedBtn = document.createElement('button');
        aggregatedBtn.className = `flex-1 px-3 py-1 rounded-lg text-sm transition-colors ${
            this.viewMode === 'aggregated' ? 'bg-blue-500 text-white' : 'bg-white/10 text-white hover:bg-white/20'
        }`;
        aggregatedBtn.textContent = 'Combined';
        aggregatedBtn.addEventListener('click', () => {
            this.viewMode = 'aggregated';
            this.updateDateRangeUI();
            this.updateVisualizations();
        });
        
        const breakdownBtn = document.createElement('button');
        breakdownBtn.className = `flex-1 px-3 py-1 rounded-lg text-sm transition-colors ${
            this.viewMode === 'breakdown' ? 'bg-blue-500 text-white' : 'bg-white/10 text-white hover:bg-white/20'
        }`;
        breakdownBtn.textContent = 'Monthly';
        breakdownBtn.addEventListener('click', () => {
            this.viewMode = 'breakdown';
            this.updateDateRangeUI();
            this.updateVisualizations();
        });
        
        viewModeToggle.appendChild(aggregatedBtn);
        viewModeToggle.appendChild(breakdownBtn);
        viewModeContainer.appendChild(viewModeToggle);
        section.appendChild(viewModeContainer);
        
        // Date range selectors
        const dateRangeContainer = document.createElement('div');
        dateRangeContainer.className = 'space-y-3';
        
        // Start date
        const startContainer = document.createElement('div');
        const startLabel = document.createElement('label');
        startLabel.className = 'text-white/90 text-sm block mb-1';
        startLabel.textContent = 'Start Month:';
        
        const startSelect = document.createElement('select');
        startSelect.className = 'w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-white';
        startSelect.id = 'start-month-select';
        
        const sortedMonths = Array.from(this.months).sort();
        sortedMonths.forEach(month => {
            const option = document.createElement('option');
            option.value = month;
            option.textContent = month;
            option.selected = this.selectedStartMonth === month;
            option.className = 'text-gray-800';
            startSelect.appendChild(option);
        });
        
        startSelect.addEventListener('change', () => {
            this.selectedStartMonth = startSelect.value;
            this.validateDateRange();
            this.updateVisualizations();
            this.updateFilterTags();
        });
        
        startContainer.appendChild(startLabel);
        startContainer.appendChild(startSelect);
        
        // End date
        const endContainer = document.createElement('div');
        const endLabel = document.createElement('label');
        endLabel.className = 'text-white/90 text-sm block mb-1';
        endLabel.textContent = 'End Month:';
        
        const endSelect = document.createElement('select');
        endSelect.className = 'w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-white';
        endSelect.id = 'end-month-select';
        
        sortedMonths.forEach(month => {
            const option = document.createElement('option');
            option.value = month;
            option.textContent = month;
            option.selected = this.selectedEndMonth === month;
            option.className = 'text-gray-800';
            endSelect.appendChild(option);
        });
        
        endSelect.addEventListener('change', () => {
            this.selectedEndMonth = endSelect.value;
            this.validateDateRange();
            this.updateVisualizations();
            this.updateFilterTags();
        });
        
        endContainer.appendChild(endLabel);
        endContainer.appendChild(endSelect);
        
        dateRangeContainer.appendChild(startContainer);
        dateRangeContainer.appendChild(endContainer);
        section.appendChild(dateRangeContainer);
        
        return section;
    }
    
    updateDateRangeUI() {
        // Update view mode buttons
        const aggregatedBtn = document.querySelector('.glass-dark button:nth-child(1)');
        const breakdownBtn = document.querySelector('.glass-dark button:nth-child(2)');
        
        if (aggregatedBtn && breakdownBtn) {
            if (this.viewMode === 'aggregated') {
                aggregatedBtn.className = 'flex-1 px-3 py-1 rounded-lg text-sm transition-colors bg-blue-500 text-white';
                breakdownBtn.className = 'flex-1 px-3 py-1 rounded-lg text-sm transition-colors bg-white/10 text-white hover:bg-white/20';
            } else {
                aggregatedBtn.className = 'flex-1 px-3 py-1 rounded-lg text-sm transition-colors bg-white/10 text-white hover:bg-white/20';
                breakdownBtn.className = 'flex-1 px-3 py-1 rounded-lg text-sm transition-colors bg-blue-500 text-white';
            }
        }
    }
    
    validateDateRange() {
        const sortedMonths = Array.from(this.months).sort();
        const startIndex = sortedMonths.indexOf(this.selectedStartMonth);
        const endIndex = sortedMonths.indexOf(this.selectedEndMonth);
        
        // Auto-correct: if end is before start, set end to start
        if (endIndex < startIndex) {
            this.selectedEndMonth = this.selectedStartMonth;
            
            // Update the end select dropdown
            const endSelect = document.getElementById('end-month-select');
            if (endSelect) {
                endSelect.value = this.selectedEndMonth;
            }
        }
    }
    
    createFilterSection(title, items, selected, type, isSelect = false) {
        const section = document.createElement('div');
        section.className = 'glass-dark rounded-xl p-4';
        
        const header = document.createElement('h4');
        header.className = 'font-medium text-white mb-3';
        header.textContent = title;
        section.appendChild(header);
        
        if (isSelect) {
            const select = document.createElement('select');
            select.className = 'w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-white';
            
            items.forEach(item => {
                const option = document.createElement('option');
                option.value = item;
                option.textContent = item;
                option.selected = selected === item;
                option.className = 'text-gray-800';
                select.appendChild(option);
            });
            
            select.addEventListener('change', () => {
                if (type === 'month') this.selectedMonth = select.value;
                this.updateVisualizations();
                this.updateFilterTags();
            });
            
            section.appendChild(select);
        } else {
            const buttons = document.createElement('div');
            buttons.className = 'flex space-x-2 mb-3';
            
            const selectAll = document.createElement('button');
            selectAll.className = 'flex-1 bg-white/10 hover:bg-white/20 text-white px-3 py-1 rounded-lg text-sm transition-colors';
            selectAll.textContent = 'All';
            selectAll.addEventListener('click', () => {
                if (type === 'regions') this.selectedRegions = Array.from(this.regions);
                if (type === 'plants') this.selectedPlants = Array.from(this.plants);
                if (type === 'materials') this.selectedMaterials = Array.from(this.materials);
                this.updateFilters();
                this.updateVisualizations();
            });
            
            const selectNone = document.createElement('button');
            selectNone.className = 'flex-1 bg-white/10 hover:bg-white/20 text-white px-3 py-1 rounded-lg text-sm transition-colors';
            selectNone.textContent = 'None';
            selectNone.addEventListener('click', () => {
                if (type === 'regions') this.selectedRegions = [];
                if (type === 'plants') this.selectedPlants = [];
                if (type === 'materials') this.selectedMaterials = [];
                this.updateFilters();
                this.updateVisualizations();
            });
            
            buttons.appendChild(selectAll);
            buttons.appendChild(selectNone);
            section.appendChild(buttons);
            
            const itemsContainer = document.createElement('div');
            itemsContainer.className = 'space-y-2 max-h-32 overflow-y-auto';
            
            items.forEach(item => {
                const label = document.createElement('label');
                label.className = 'flex items-center space-x-2 cursor-pointer hover:bg-white/5 rounded p-1 transition-colors';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'rounded border-white/30 bg-white/10 text-blue-500';
                checkbox.checked = selected.includes(item);
                
                checkbox.addEventListener('change', () => {
                    let targetArray;
                    if (type === 'regions') targetArray = this.selectedRegions;
                    if (type === 'plants') targetArray = this.selectedPlants;
                    if (type === 'materials') targetArray = this.selectedMaterials;
                    
                    if (checkbox.checked) {
                        if (!targetArray.includes(item)) targetArray.push(item);
                    } else {
                        const index = targetArray.indexOf(item);
                        if (index > -1) targetArray.splice(index, 1);
                    }
                    
                    this.updateVisualizations();
                    this.updateFilterTags();
                });
                
                const span = document.createElement('span');
                span.className = 'text-white/90 text-sm';
                span.textContent = item;
                
                label.appendChild(checkbox);
                label.appendChild(span);
                itemsContainer.appendChild(label);
            });
            
            section.appendChild(itemsContainer);
        }
        
        return section;
    }
    
    updateFilterTags() {
        const filterTags = document.getElementById('filter-tags');
        filterTags.innerHTML = '';
        
        const tags = [
            { label: `Period: ${this.selectedStartMonth}${this.selectedStartMonth !== this.selectedEndMonth ? ` to ${this.selectedEndMonth}` : ''}`, type: 'period' },
            { label: `Regions: ${this.selectedRegions.length}`, type: 'regions' },
            { label: `Plants: ${this.selectedPlants.length}`, type: 'plants' },
            { label: `Materials: ${this.selectedMaterials.length}`, type: 'materials' },
            { label: `View: ${this.viewMode === 'aggregated' ? 'Combined' : 'Monthly'}`, type: 'view' }
        ];
        
        tags.forEach(tag => {
            const tagElement = document.createElement('span');
            tagElement.className = 'filter-tag';
            tagElement.textContent = tag.label;
            filterTags.appendChild(tagElement);
        });
    }
    
    filterData() {
        const selectedMonths = this.getSelectedMonthsRange();
        
        this.filteredData = this.data.filter(item => 
            this.selectedRegions.includes(item.region) &&
            this.selectedPlants.includes(item.plant) &&
            this.selectedMaterials.includes(item.normalizedMaterial) &&
            selectedMonths.includes(item.monthYear)
        );
    }
    
    getSelectedMonthsRange() {
        const sortedMonths = Array.from(this.months).sort();
        const startIndex = sortedMonths.indexOf(this.selectedStartMonth);
        const endIndex = sortedMonths.indexOf(this.selectedEndMonth);
        
        return sortedMonths.slice(startIndex, endIndex + 1);
    }
    
    updateVisualizations() {
        this.filterData();
        this.updateMetricCards();
        this.updateCharts();
        this.updateTable();
        this.updateDashboardSubtitle();
    }
    
    updateDashboardSubtitle() {
        const subtitle = document.getElementById('dashboard-subtitle');
        if (this.filteredData.length > 0) {
            const uniquePlants = new Set(this.filteredData.map(d => d.plant)).size;
            const selectedMonths = this.getSelectedMonthsRange();
            const periodText = selectedMonths.length === 1 ? selectedMonths[0] : 
                `${selectedMonths[0]} to ${selectedMonths[selectedMonths.length - 1]}`;
            subtitle.textContent = `${this.filteredData.length.toLocaleString()} batches ‚Ä¢ ${uniquePlants} plants ‚Ä¢ ${periodText}`;
        }
    }
    
    updateMetricCards() {
        const metricCards = document.getElementById('metric-cards');
        metricCards.innerHTML = '';
        
        if (this.filteredData.length === 0) {
            metricCards.innerHTML = '<p class="col-span-full text-center text-white/60">No data matches current filters</p>';
            return;
        }
        
        const stats = this.calculateStats();
        
        const cards = [
            {
                title: 'Total Batches',
                value: stats.totalBatches.toLocaleString(),
                icon: 'üìä',
                color: this.colors.primary,
                subtitle: `Across ${new Set(this.filteredData.map(d => d.plant)).size} plants`
            },
            {
                title: 'Average Error',
                value: `${stats.avgError.toFixed(2)}%`,
                icon: 'üéØ',
                color: Math.abs(stats.avgError) > 1 ? this.colors.waste : this.colors.optimal,
                subtitle: stats.avgError > 0 ? 'Over target' : 'Under target'
            },
            {
                title: 'Optimal Batches',
                value: `${((stats.optimal / stats.totalBatches) * 100).toFixed(1)}%`,
                icon: '‚úÖ',
                color: this.colors.optimal,
                subtitle: `${stats.optimal} batches`
            },
            {
                title: 'Risk/Waste',
                value: `${(((stats.risk + stats.waste) / stats.totalBatches) * 100).toFixed(1)}%`,
                icon: '‚ö†Ô∏è',
                color: this.colors.waste,
                subtitle: `${stats.risk + stats.waste} batches`
            }
        ];
        
        cards.forEach(card => {
            const cardElement = document.createElement('div');
            cardElement.className = 'metric-card rounded-2xl p-6 animate-slide-up';
            cardElement.style.borderLeftColor = card.color;
            
            cardElement.innerHTML = `
                <div class="flex items-center justify-between mb-2">
                    <span class="text-2xl">${card.icon}</span>
                    <span class="text-2xl font-bold" style="color: ${card.color}">${card.value}</span>
                </div>
                <h3 class="font-semibold text-gray-800 mb-1">${card.title}</h3>
                <p class="text-sm text-gray-600">${card.subtitle}</p>
            `;
            
            metricCards.appendChild(cardElement);
        });
    }
    
    calculateStats() {
        const statusCounts = _.countBy(this.filteredData, 'status');
        const avgError = _.sumBy(this.filteredData, 'errorPercent') / this.filteredData.length;
        
        return {
            totalBatches: this.filteredData.length,
            avgError,
            optimal: statusCounts.optimal || 0,
            good: statusCounts.good || 0,
            risk: statusCounts.risk || 0,
            waste: statusCounts.waste || 0
        };
    }
    
    updateCharts() {
        this.updateTrendChart();
        this.updateDistributionChart();
        this.updateMaterialChart();
    }
    
    updateTrendChart() {
        const ctx = document.getElementById('trend-chart').getContext('2d');
        
        if (this.charts.trend) {
            this.charts.trend.destroy();
        }
        
        let datasets = [];
        let weeks = [];
        let weeklyData = {};
        
        if (this.viewMode === 'aggregated') {
            // Combined view - treat all data as one period
            weeklyData = _.groupBy(this.filteredData, 'weekStart');
            weeks = Object.keys(weeklyData).sort();
            
            if (this.selectedPlants.length <= 4) {
                const plantColors = this.generateColorPalette(this.selectedPlants.length);
                
                this.selectedPlants.forEach((plant, index) => {
                    const plantData = weeks.map(week => {
                        const weekBatches = weeklyData[week]?.filter(b => b.plant === plant) || [];
                        return weekBatches.length > 0 ? 
                            _.sumBy(weekBatches, 'errorPercent') / weekBatches.length : null;
                    });
                    
                    const cleanPlantName = plant.replace(/PLANT \d+ - /gi, '').replace(/\(\d+\)/g, '').trim();
                    
                    datasets.push({
                        label: cleanPlantName,
                        data: plantData,
                        borderColor: plantColors[index],
                        backgroundColor: plantColors[index] + '20',
                        borderWidth: 3,
                        tension: 0.4,
                        fill: false,
                        pointRadius: 4,
                        pointHoverRadius: 6
                    });
                });
            } else {
                const regionData = {};
                
                this.filteredData.forEach(batch => {
                    let region = batch.region || 'Unknown';
                    region = region.trim().toUpperCase();
                    if (region.includes('ALLIED')) region = 'ALLIED';
                    if (region.includes('RK HALL') || region.includes('HALL')) region = 'RK HALL';
                    
                    if (!regionData[region]) regionData[region] = {};
                    const week = batch.weekStart;
                    if (!regionData[region][week]) regionData[region][week] = [];
                    regionData[region][week].push(batch.errorPercent);
                });
                
                const regionColors = this.generateColorPalette(Object.keys(regionData).length);
                
                Object.keys(regionData).forEach((region, index) => {
                    const regionWeeklyAvg = weeks.map(week => {
                        const weekErrors = regionData[region][week];
                        return weekErrors && weekErrors.length > 0 ? 
                            _.sum(weekErrors) / weekErrors.length : null;
                    });
                    
                    datasets.push({
                        label: `${region} Region`,
                        data: regionWeeklyAvg,
                        borderColor: regionColors[index],
                        backgroundColor: regionColors[index] + '20',
                        borderWidth: 4,
                        tension: 0.4,
                        fill: false,
                        pointRadius: 5,
                        pointHoverRadius: 8
                    });
                });
            }
        } else {
            // Monthly breakdown view
            const selectedMonths = this.getSelectedMonthsRange();
            const monthColors = this.generateColorPalette(selectedMonths.length);
            
            selectedMonths.forEach((month, monthIndex) => {
                const monthData = this.filteredData.filter(b => b.monthYear === month);
                const monthWeeklyData = _.groupBy(monthData, 'weekStart');
                const monthWeeks = Object.keys(monthWeeklyData).sort();
                
                // Extend weeks array to include all weeks from all months
                monthWeeks.forEach(week => {
                    if (!weeks.includes(week)) weeks.push(week);
                });
                
                // Calculate average error for this month across all selected regions/plants
                const monthlyAvg = monthWeeks.map(week => {
                    const weekBatches = monthWeeklyData[week] || [];
                    return weekBatches.length > 0 ? 
                        _.sumBy(weekBatches, 'errorPercent') / weekBatches.length : null;
                });
                
                // Create full data array with nulls for weeks not in this month
                weeks.sort();
                const fullMonthData = weeks.map(week => {
                    const weekIndex = monthWeeks.indexOf(week);
                    return weekIndex >= 0 ? monthlyAvg[weekIndex] : null;
                });
                
                datasets.push({
                    label: month,
                    data: fullMonthData,
                    borderColor: monthColors[monthIndex],
                    backgroundColor: monthColors[monthIndex] + '20',
                    borderWidth: 3,
                    tension: 0.4,
                    fill: false,
                    pointRadius: 4,
                    pointHoverRadius: 6
                });
            });
        }
        
        const allValues = datasets.flatMap(d => d.data.filter(v => v !== null));
        const minValue = allValues.length > 0 ? Math.min(...allValues) : -1;
        const maxValue = allValues.length > 0 ? Math.max(...allValues) : 1;
        const range = Math.max(Math.abs(minValue), Math.abs(maxValue));
        const padding = range * 0.2;
        
        this.charts.trend = new Chart(ctx, {
            type: 'line',
            data: {
                labels: weeks.map(week => {
                    const date = new Date(week);
                    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                }),
                datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: { intersect: false, mode: 'index' },
                plugins: {
                    legend: {
                        position: 'top',
                        labels: { usePointStyle: true, padding: 20, font: { size: 12 } }
                    },
                    tooltip: {
                        backgroundColor: 'rgba(0,0,0,0.8)',
                        titleColor: 'white',
                        bodyColor: 'white',
                        borderColor: 'rgba(255,255,255,0.2)',
                        borderWidth: 1,
                        cornerRadius: 8,
                        callbacks: {
                            label: function(context) {
                                const value = context.parsed.y;
                                if (value === null) return null;
                                return `${context.dataset.label}: ${value.toFixed(2)}%`;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        title: { display: true, text: 'Average Error %', font: { weight: 'bold' } },
                        min: Math.min(-1, minValue - padding),
                        max: Math.max(1, maxValue + padding),
                        ticks: {
                            callback: value => `${value.toFixed(1)}%`,
                            stepSize: 0.1
                        },
                        grid: { color: 'rgba(0,0,0,0.1)', drawBorder: true }
                    },
                    x: {
                        title: { display: true, text: 'Week Starting', font: { weight: 'bold' } },
                        grid: { color: 'rgba(0,0,0,0.1)' }
                    }
                }
            }
        });
    }
    
    updateDistributionChart() {
        const ctx = document.getElementById('distribution-chart').getContext('2d');
        
        if (this.charts.distribution) {
            this.charts.distribution.destroy();
        }
        
        const plantStats = {};
        this.selectedPlants.forEach(plant => {
            const plantBatches = this.filteredData.filter(b => b.plant === plant);
            const statusCounts = _.countBy(plantBatches, 'status');
            const total = plantBatches.length;
            
            if (total > 0) {
                plantStats[plant] = {
                    optimal: (statusCounts.optimal || 0) / total * 100,
                    good: (statusCounts.good || 0) / total * 100,
                    risk: (statusCounts.risk || 0) / total * 100,
                    waste: (statusCounts.waste || 0) / total * 100,
                    total: total
                };
            }
        });
        
        const plants = Object.keys(plantStats);
        const cleanPlantNames = plants.map(plant => 
            plant.replace(/PLANT \d+ - /gi, '').replace(/\(\d+\)/g, '').trim()
        );
        
        const datasets = [
            {
                label: 'Optimal',
                data: plants.map(plant => plantStats[plant].optimal),
                backgroundColor: this.colors.optimal
            },
            {
                label: 'Good',
                data: plants.map(plant => plantStats[plant].good),
                backgroundColor: this.colors.good
            },
            {
                label: 'Risk',
                data: plants.map(plant => plantStats[plant].risk),
                backgroundColor: this.colors.risk
            },
            {
                label: 'Waste',
                data: plants.map(plant => plantStats[plant].waste),
                backgroundColor: this.colors.waste
            }
        ];
        
        this.charts.distribution = new Chart(ctx, {
            type: 'bar',
            data: { labels: cleanPlantNames, datasets },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: { intersect: false, mode: 'index' },
                scales: {
                    x: { 
                        stacked: true,
                        title: { display: true, text: 'Plants', font: { weight: 'bold' } }
                    },
                    y: { 
                        stacked: true,
                        title: { display: true, text: 'Percentage of Batches', font: { weight: 'bold' } },
                        ticks: { callback: value => `${value.toFixed(0)}%` },
                        grid: { color: 'rgba(0,0,0,0.1)' }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top',
                        labels: { usePointStyle: true, padding: 15 }
                    },
                    tooltip: {
                        backgroundColor: 'rgba(0,0,0,0.8)',
                        titleColor: 'white',
                        bodyColor: 'white',
                        borderColor: 'rgba(255,255,255,0.2)',
                        borderWidth: 1,
                        cornerRadius: 8,
                        callbacks: {
                            title: function(context) {
                                const plantIndex = context[0].dataIndex;
                                const originalPlant = plants[plantIndex];
                                const total = plantStats[originalPlant].total;
                                return `${context[0].label} (${total} batches)`;
                            },
                            label: function(context) {
                                const value = context.parsed.y;
                                const plantIndex = context.dataIndex;
                                const originalPlant = plants[plantIndex];
                                const total = plantStats[originalPlant].total;
                                const count = Math.round((value / 100) * total);
                                return `${context.dataset.label}: ${value.toFixed(1)}% (${count} batches)`;
                            }
                        }
                    }
                },
                onHover: function(event, activeElements) {
                    event.native.target.style.cursor = activeElements.length > 0 ? 'pointer' : 'default';
                }
            },
            plugins: [{
                id: 'percentageLabels',
                afterDatasetsDraw: function(chart) {
                    const ctx = chart.ctx;
                    chart.data.datasets.forEach((dataset, datasetIndex) => {
                        const meta = chart.getDatasetMeta(datasetIndex);
                        meta.data.forEach((bar, index) => {
                            const value = dataset.data[index];
                            if (value >= 5) {
                                const x = bar.x;
                                const y = bar.y + (bar.height / 2);
                                
                                ctx.save();
                                
                                // Smart contrast: use dark text on light colors, light text on dark colors
                                const color = dataset.backgroundColor;
                                let textColor = '#000000';
                                
                                if (color === '#10b981' || color === '#eab308') { // optimal, good
                                    textColor = '#000000';
                                } else { // risk, waste
                                    textColor = '#ffffff';
                                }
                                
                                ctx.fillStyle = textColor;
                                ctx.font = 'bold 11px Inter, sans-serif';
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                
                                // Add subtle shadow for better readability
                                if (textColor === '#ffffff') {
                                    ctx.shadowColor = 'rgba(0,0,0,0.7)';
                                    ctx.shadowBlur = 2;
                                    ctx.shadowOffsetX = 1;
                                    ctx.shadowOffsetY = 1;
                                } else {
                                    ctx.shadowColor = 'rgba(255,255,255,0.7)';
                                    ctx.shadowBlur = 2;
                                    ctx.shadowOffsetX = 1;
                                    ctx.shadowOffsetY = 1;
                                }
                                
                                // Only show if bar is wide enough (prevent text overflow)
                                if (bar.width > 40) {
                                    ctx.fillText(`${value.toFixed(1)}%`, x, y);
                                }
                                
                                ctx.restore();
                            }
                        });
                    });
                }
            }]
        });
    }
    
    updateMaterialChart() {
        const ctx = document.getElementById('material-chart').getContext('2d');
        
        if (this.charts.material) {
            this.charts.material.destroy();
        }
        
        const materialStats = {};
        this.selectedMaterials.forEach(material => {
            const materialBatches = this.filteredData.filter(b => b.normalizedMaterial === material);
            if (materialBatches.length > 0) {
                const avgError = _.sumBy(materialBatches, 'errorPercent') / materialBatches.length;
                const statusCounts = _.countBy(materialBatches, 'status');
                
                materialStats[material] = {
                    avgError,
                    count: materialBatches.length,
                    optimal: statusCounts.optimal || 0,
                    risk: statusCounts.risk || 0,
                    waste: statusCounts.waste || 0
                };
            }
        });
        
        const materials = Object.keys(materialStats);
        
        this.charts.material = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: materials,
                datasets: [{
                    label: 'Average Error %',
                    data: materials.map(material => materialStats[material].avgError),
                    backgroundColor: materials.map((material) => {
                        const error = materialStats[material].avgError;
                        if (error <= 0 && error >= -1) return this.colors.optimal + '80';
                        if (error > 0 && error <= 1) return this.colors.good + '80';
                        if (error < -1) return this.colors.risk + '80';
                        return this.colors.waste + '80';
                    }),
                    borderColor: materials.map((material) => {
                        const error = materialStats[material].avgError;
                        if (error <= 0 && error >= -1) return this.colors.optimal;
                        if (error > 0 && error <= 1) return this.colors.good;
                        if (error < -1) return this.colors.risk;
                        return this.colors.waste;
                    }),
                    borderWidth: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        title: { display: true, text: 'Average Error %', font: { weight: 'bold' } },
                        ticks: { callback: value => `${value.toFixed(1)}%` }
                    },
                    x: {
                        title: { display: true, text: 'Materials', font: { weight: 'bold' } }
                    }
                },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            afterLabel: (context) => {
                                const material = materials[context.dataIndex];
                                const stats = materialStats[material];
                                return [
                                    `Batches: ${stats.count}`,
                                    `Optimal: ${stats.optimal}`,
                                    `Risk: ${stats.risk}`,
                                    `Waste: ${stats.waste}`
                                ];
                            }
                        }
                    }
                },
                onClick: (event, elements) => {
                    if (elements.length > 0) {
                        const index = elements[0].index;
                        const material = materials[index];
                        this.showMaterialDetails(material);
                    }
                }
            }
        });
    }
    
    updateTable() {
        const tableHeader = document.getElementById('table-header');
        const tableBody = document.getElementById('table-body');
        
        tableHeader.innerHTML = '';
        tableBody.innerHTML = '';
        
        const headers = ['Material', 'Total Batches', 'Avg Error %', 'Optimal', 'Good', 'Risk', 'Waste'];
        headers.forEach(header => {
            const th = document.createElement('th');
            th.className = 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider';
            th.textContent = header;
            tableHeader.appendChild(th);
        });
        
        this.selectedMaterials.forEach(material => {
            const materialBatches = this.filteredData.filter(b => b.normalizedMaterial === material);
            
            if (materialBatches.length > 0) {
                const avgError = _.sumBy(materialBatches, 'errorPercent') / materialBatches.length;
                const statusCounts = _.countBy(materialBatches, 'status');
                
                const row = document.createElement('tr');
                row.className = 'table-row cursor-pointer hover:bg-gray-50';
                row.addEventListener('click', () => this.showMaterialDetails(material));
                
                const cells = [
                    material,
                    materialBatches.length.toLocaleString(),
                    `${avgError.toFixed(2)}%`,
                    statusCounts.optimal || 0,
                    statusCounts.good || 0,
                    statusCounts.risk || 0,
                    statusCounts.waste || 0
                ];
                
                cells.forEach((cell, index) => {
                    const td = document.createElement('td');
                    td.className = 'px-6 py-4 whitespace-nowrap text-sm';
                    
                    if (index === 0) {
                        td.className += ' font-medium text-gray-900';
                    } else if (index === 2) {
                        const error = parseFloat(cell);
                        if (Math.abs(error) <= 1) {
                            td.className += ' text-green-600 font-semibold';
                        } else {
                            td.className += ' text-red-600 font-semibold';
                        }
                    } else {
                        td.className += ' text-gray-600';
                    }
                    
                    td.textContent = cell;
                    row.appendChild(td);
                });
                
                tableBody.appendChild(row);
            }
        });
    }
    
    showMaterialDetails(material) {
        const modal = document.getElementById('modal');
        const modalTitle = document.getElementById('modal-title');
        const modalTableBody = document.getElementById('modal-table-body');
        
        modalTitle.textContent = `Material Details: ${material}`;
        modalTableBody.innerHTML = '';
        
        const materialBatches = this.filteredData
            .filter(b => b.normalizedMaterial === material)
            .sort((a, b) => new Date(b.ticketDate) - new Date(a.ticketDate));
        
        materialBatches.forEach(batch => {
            const row = document.createElement('tr');
            row.className = 'hover:bg-gray-50';
            
            const statusIndicator = document.createElement('span');
            statusIndicator.className = `performance-indicator ${batch.status}`;
            
            row.innerHTML = `
                <td class="px-4 py-3 whitespace-nowrap text-sm font-medium text-gray-900">${batch.plant.replace(/PLANT \d+ - /gi, '').replace(/\(\d+\)/g, '').trim()}</td>
                <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-600">${new Date(batch.ticketDate).toLocaleDateString()}</td>
                <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-600">${batch['Ticket number']}</td>
                <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-600">${batch.target.toFixed(2)}</td>
                <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-600">${batch.actual.toFixed(2)}</td>
                <td class="px-4 py-3 whitespace-nowrap text-sm font-semibold ${Math.abs(batch.errorPercent) > 1 ? 'text-red-600' : 'text-green-600'}">${batch.errorPercent.toFixed(2)}%</td>
                <td class="px-4 py-3 whitespace-nowrap text-sm">
                    <span class="inline-flex items-center">
                        ${statusIndicator.outerHTML}
                        ${batch.status.charAt(0).toUpperCase() + batch.status.slice(1)}
                    </span>
                </td>
            `;
            
            modalTableBody.appendChild(row);
        });
        
        modal.classList.remove('hidden');
    }
    
    generateColorPalette(count) {
        const colors = [];
        for (let i = 0; i < count; i++) {
            const hue = (i * 360 / count) % 360;
            colors.push(`hsl(${hue}, 70%, 50%)`);
        }
        return colors;
    }
    
    showLoading() {
        document.getElementById('loading').classList.remove('hidden');
        document.getElementById('controls').classList.add('hidden');
    }
    
    hideLoading() {
        document.getElementById('loading').classList.add('hidden');
        document.getElementById('controls').classList.remove('hidden');
    }
    
    showDashboard() {
        document.getElementById('welcome').classList.add('hidden');
        document.getElementById('dashboard').classList.remove('hidden');
    }
    
    clearData() {
        this.data = [];
        this.filteredData = [];
        
        Object.values(this.charts).forEach(chart => chart.destroy());
        this.charts = {};
        
        document.getElementById('welcome').classList.remove('hidden');
        document.getElementById('dashboard').classList.add('hidden');
        document.getElementById('filters').classList.add('hidden');
        document.getElementById('controls').classList.add('hidden');
        
        document.getElementById('file-input').value = '';
        
        this.materials.clear();
        this.regions.clear();
        this.plants.clear();
        this.months.clear();
    }
}

document.addEventListener('DOMContentLoaded', () => {
    new ConcreteAnalyzer();
});
</script>
</body>
</html>
